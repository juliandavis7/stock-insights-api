# Code Generated by Sidekick is for learning and experimentation purposes only.
from fastapi import FastAPI, HTTPException, Query, Depends
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Dict
import httpx
import logging
from datetime import datetime
from models import MetricsResponse, ProjectionRequest, ProjectionResponse, ProjectionBaseDataResponse, ErrorResponse, FinancialStatementResponse, FinancialDataResponse, AnalystEstimateResponse, ComprehensiveFinancialResponse
from util import get_metrics, fetch_fmp_analyst_estimates, extract_metric_by_year, calculate_financial_projections, validate_projection_inputs, fetch_chart_data, fetch_enhanced_chart_data
from services.projection_service import ProjectionService
from services.yfinance_service import YFinanceService
from services.fmp_service import FMPService
from constants.constants import FMP_API_KEY
from auth import verify_token

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('api.log')
    ]
)

logger = logging.getLogger(__name__)

app = FastAPI()

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:5173", 
        "http://127.0.0.1:5173"  # React frontend local
    ],
    allow_origin_regex=r"https://stock-insights-.*\.vercel\.app",  # All Vercel preview deployments
    allow_credentials=True,
    allow_methods=["GET", "POST"],  # Only allow necessary methods
    allow_headers=["Content-Type", "Authorization"],  # Restrict headers
)

@app.on_event("startup")
async def startup_event():
    import os
    environment = os.getenv('ENVIRONMENT', 'production').lower()
    logging.info("🚀 Stock Insights API started with enhanced logging")
    logging.info("📊 Debug logs will be visible for current year growth calculations")
    if environment == 'local':
        logging.warning("⚠️  Running in LOCAL mode - Authentication is BYPASSED")
    else:
        logging.info(f"🔒 Running in {environment.upper()} mode - Authentication is REQUIRED")


@app.get("/health")
def health_check():
    return {"status": "ok"}

@app.get("/metrics", response_model=MetricsResponse)
def metrics(ticker: str = Query(..., description="Stock ticker symbol"), user: Dict = Depends(verify_token)):
    try:
        data = get_metrics(ticker)
        return data
    except Exception as e:
        logging.error(f"❌ API: Error in metrics endpoint for {ticker}: {e}")
        import traceback
        logging.error(f"❌ API: Full traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Error calculating metrics: {str(e)}")

@app.get("/revenue")
def get_revenue(ticker: str = Query(..., description="Stock ticker symbol"), user: Dict = Depends(verify_token)):
    fmp_data = fetch_fmp_analyst_estimates(ticker)
    if not fmp_data:
        raise HTTPException(status_code=404, detail="No data found for ticker")
    revenue_dict = extract_metric_by_year(fmp_data, "estimatedRevenueAvg")
    return revenue_dict

# Code Generated by Sidekick is for learning and experimentation purposes only.
@app.get("/net-income")
def get_net_income(ticker: str = Query(..., description="Stock ticker symbol"), user: Dict = Depends(verify_token)):
    fmp_data = fetch_fmp_analyst_estimates(ticker)
    if not fmp_data:
        raise HTTPException(status_code=404, detail="No data found for ticker")
    net_income_dict = extract_metric_by_year(fmp_data, "estimatedNetIncomeAvg")
    return net_income_dict

@app.get("/eps")
def get_eps(ticker: str = Query(..., description="Stock ticker symbol"), user: Dict = Depends(verify_token)):
    fmp_data = fetch_fmp_analyst_estimates(ticker)
    if not fmp_data:
        raise HTTPException(status_code=404, detail="No data found for ticker")
    eps_dict = extract_metric_by_year(fmp_data, "estimatedEpsAvg")
    return eps_dict

@app.post("/projections", response_model=ProjectionResponse)
async def create_financial_projections(
    request: ProjectionRequest,
    ticker: str = Query(..., description="Stock ticker symbol (e.g., AAPL)", regex="^[A-Z]{1,5}$"),
    user: Dict = Depends(verify_token)
):
    """
    Calculate financial projections for a stock based on user assumptions.
    
    Args:
        ticker: Stock ticker symbol as query parameter
        request: Projection inputs in request body
    
    Returns:
        Financial projections including revenue, net income, EPS, stock price ranges, and CAGR
    """
    # Convert Pydantic models to dictionary format expected by utils
    projection_inputs = {}
    for year, projection in request.projections.items():
        projection_inputs[year] = {
            'revenue_growth': projection.revenue_growth,
            'net_income_growth': projection.net_income_growth,
            'net_income_margin': projection.net_income_margin,
            'pe_low': projection.pe_low,
            'pe_high': projection.pe_high
        }
    
    # Validate inputs using utility function
    validation_errors = validate_projection_inputs(projection_inputs)
    if validation_errors:
        raise HTTPException(
            status_code=400, 
            detail={
                "error": "Validation failed",
                "details": validation_errors
            }
        )
    
    # Calculate projections
    try:
        result = calculate_financial_projections(
            ticker=ticker.upper(),
            api_key=FMP_API_KEY,
            projection_inputs=projection_inputs
        )
        
        if not result.get('success', True):
            raise HTTPException(
                status_code=400,
                detail={
                    "error": result.get('error', 'Unknown error occurred'),
                    "ticker": ticker
                }
            )
        
        return ProjectionResponse(**result)
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": f"Internal server error: {str(e)}",
                "ticker": ticker
            }
        )


@app.get("/projections", response_model=ProjectionBaseDataResponse)
def get_projection_base_data(ticker: str = Query(..., description="Stock ticker symbol"), user: Dict = Depends(verify_token)):
    """
    Get base data for financial projections including current stock metrics.
    
    Args:
        ticker: Stock ticker symbol (e.g., CELH, AAPL)
        
    Returns:
        Base data including price, market cap, shares outstanding, and financial metrics
    """
    try:
        projection_service = ProjectionService()
        data = projection_service.get_stock_current_data(ticker.upper(), FMP_API_KEY)
        
        if not data:
            raise HTTPException(
                status_code=404,
                detail={
                    "error": f"Unable to fetch data for ticker {ticker}",
                    "ticker": ticker.upper()
                }
            )
        
        # Calculate net income margin if we have both net income and revenue
        net_income_margin = None
        if data.get('net_income') and data.get('revenue') and data['revenue'] > 0:
            net_income_margin = int(round((data['net_income'] / data['revenue']) * 100))
        
        return ProjectionBaseDataResponse(
            ticker=data['ticker'],
            # Stock info fields removed - use /info endpoint instead
            revenue=data.get('revenue'),
            net_income=data.get('net_income'),
            eps=data.get('current_year_eps'),
            net_income_margin=net_income_margin,
            data_year=data['data_year']
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": f"Internal server error: {str(e)}",
                "ticker": ticker.upper()
            }
        )


@app.get("/mock-income-statement", response_model=List[FinancialStatementResponse])
def get_financial_statements(ticker: str = Query(..., description="Stock ticker symbol"), user: Dict = Depends(verify_token)):
    """
    Mock endpoint to return hardcoded financial statement data for development.
    Returns 3 years of mock data (2024, 2023, 2022) similar to FMP API response.
    
    Args:
        ticker: Stock ticker symbol (e.g., AAPL)
        
    Returns:
        List of financial statement data for the past 3 years
    """
    # Mock financial data for different tickers
    mock_data = {
        "AAPL": [
            {
                "date": "2024-09-28",
                "symbol": "AAPL",
                "reportedCurrency": "USD",
                "cik": "0000320193",
                "filingDate": "2024-11-01",
                "acceptedDate": "2024-11-01 06:01:36",
                "fiscalYear": "2024",
                "period": "FY",
                "revenue": 391035000000,
                "costOfRevenue": 210352000000,
                "grossProfit": 180683000000,
                "researchAndDevelopmentExpenses": 31370000000,
                "generalAndAdministrativeExpenses": 0,
                "sellingAndMarketingExpenses": 0,
                "sellingGeneralAndAdministrativeExpenses": 26097000000,
                "otherExpenses": 0,
                "operatingExpenses": 57467000000,
                "costAndExpenses": 267819000000,
                "netInterestIncome": 0,
                "interestIncome": 0,
                "interestExpense": 0,
                "depreciationAndAmortization": 11445000000,
                "ebitda": 134661000000,
                "ebit": 123216000000,
                "nonOperatingIncomeExcludingInterest": 0,
                "operatingIncome": 123216000000,
                "totalOtherIncomeExpensesNet": 269000000,
                "incomeBeforeTax": 123485000000,
                "incomeTaxExpense": 29749000000,
                "netIncomeFromContinuingOperations": 93736000000,
                "netIncomeFromDiscontinuedOperations": 0,
                "otherAdjustmentsToNetIncome": 0,
                "netIncome": 93736000000,
                "netIncomeDeductions": 0,
                "bottomLineNetIncome": 93736000000,
                "eps": 6.11,
                "epsDiluted": 6.08,
                "weightedAverageShsOut": 15343783000,
                "weightedAverageShsOutDil": 15408095000
            },
            {
                "date": "2023-09-30",
                "symbol": "AAPL",
                "reportedCurrency": "USD",
                "cik": "0000320193",
                "filingDate": "2023-11-03",
                "acceptedDate": "2023-11-03 06:01:25",
                "fiscalYear": "2023",
                "period": "FY",
                "revenue": 383285000000,
                "costOfRevenue": 214137000000,
                "grossProfit": 169148000000,
                "researchAndDevelopmentExpenses": 29915000000,
                "generalAndAdministrativeExpenses": 0,
                "sellingAndMarketingExpenses": 0,
                "sellingGeneralAndAdministrativeExpenses": 24932000000,
                "otherExpenses": 0,
                "operatingExpenses": 54847000000,
                "costAndExpenses": 268984000000,
                "netInterestIncome": 0,
                "interestIncome": 0,
                "interestExpense": 0,
                "depreciationAndAmortization": 11519000000,
                "ebitda": 125820000000,
                "ebit": 114301000000,
                "nonOperatingIncomeExcludingInterest": 0,
                "operatingIncome": 114301000000,
                "totalOtherIncomeExpensesNet": -565000000,
                "incomeBeforeTax": 113736000000,
                "incomeTaxExpense": 16741000000,
                "netIncomeFromContinuingOperations": 96995000000,
                "netIncomeFromDiscontinuedOperations": 0,
                "otherAdjustmentsToNetIncome": 0,
                "netIncome": 96995000000,
                "netIncomeDeductions": 0,
                "bottomLineNetIncome": 96995000000,
                "eps": 6.16,
                "epsDiluted": 6.13,
                "weightedAverageShsOut": 15744231000,
                "weightedAverageShsOutDil": 15812547000
            },
            {
                "date": "2022-09-24",
                "symbol": "AAPL",
                "reportedCurrency": "USD",
                "cik": "0000320193",
                "filingDate": "2022-10-28",
                "acceptedDate": "2022-10-28 06:01:15",
                "fiscalYear": "2022",
                "period": "FY",
                "revenue": 394328000000,
                "costOfRevenue": 223546000000,
                "grossProfit": 170782000000,
                "researchAndDevelopmentExpenses": 26251000000,
                "generalAndAdministrativeExpenses": 0,
                "sellingAndMarketingExpenses": 0,
                "sellingGeneralAndAdministrativeExpenses": 25094000000,
                "otherExpenses": 0,
                "operatingExpenses": 51345000000,
                "costAndExpenses": 274891000000,
                "netInterestIncome": 0,
                "interestIncome": 0,
                "interestExpense": 0,
                "depreciationAndAmortization": 11104000000,
                "ebitda": 130541000000,
                "ebit": 119437000000,
                "nonOperatingIncomeExcludingInterest": 0,
                "operatingIncome": 119437000000,
                "totalOtherIncomeExpensesNet": -334000000,
                "incomeBeforeTax": 119103000000,
                "incomeTaxExpense": 19300000000,
                "netIncomeFromContinuingOperations": 99803000000,
                "netIncomeFromDiscontinuedOperations": 0,
                "otherAdjustmentsToNetIncome": 0,
                "netIncome": 99803000000,
                "netIncomeDeductions": 0,
                "bottomLineNetIncome": 99803000000,
                "eps": 6.15,
                "epsDiluted": 6.11,
                "weightedAverageShsOut": 16215963000,
                "weightedAverageShsOutDil": 16325819000
            }
        ]
    }
    
    ticker_upper = ticker.upper()
    
    # Return AAPL data for any ticker (for development purposes)
    # In a real implementation, you would have different mock data for different tickers
    if ticker_upper in mock_data:
        return mock_data[ticker_upper]
    else:
        # Return AAPL data as default for any unknown ticker
        return mock_data["AAPL"]


@app.get("/financials", response_model=ComprehensiveFinancialResponse)
def get_financials(ticker: str = Query(..., description="Stock ticker symbol"), user: Dict = Depends(verify_token)):
    """
    Get comprehensive financial data including historical data and analyst estimates.
    Returns structured financial data with key metrics for each year plus future estimates.
    
    Args:
        ticker: Stock ticker symbol (e.g., AAPL)
        
    Returns:
        Comprehensive financial data including historical and analyst estimates
    """
    try:
        yfinance_service = YFinanceService()
        fmp_service = FMPService()
        
        # Get quarterly income statement data (from FMP API or mocks)
        quarterly_data = fmp_service.fetch_quarterly_income_statement(ticker.upper())
        
        if not quarterly_data:
            raise HTTPException(
                status_code=404,
                detail=f"No quarterly financial data available for ticker {ticker}"
            )
        
        # Derive historical annual data from quarterly data (sum by calendar year)
        # This ensures consistency with the estimates approach
        historical_data = []
        current_year = datetime.now().year
        
        # Group quarterly data by calendar year
        year_data_map = {}
        for quarter in quarterly_data:
            # Extract calendar year from date (e.g., "2024-12-31" -> 2024)
            date_str = quarter.get('date', '')
            if date_str:
                year = int(date_str.split('-')[0])
                
                # Skip current and future years (only completed years)
                if year >= current_year:
                    continue
                
                if year not in year_data_map:
                    year_data_map[year] = {
                        'quarters': [],
                        'totalRevenue': 0,
                        'costOfRevenue': 0,
                        'grossProfit': 0,
                        'sellingGeneralAndAdministrative': 0,
                        'researchAndDevelopment': 0,
                        'operatingExpenses': 0,
                        'operatingIncome': 0,
                        'netIncome': 0,
                        'eps': 0,
                        'epsDiluted': 0
                    }
                
                # Accumulate quarterly values
                year_data_map[year]['quarters'].append(quarter)
                year_data_map[year]['totalRevenue'] += quarter.get('revenue', 0) or 0
                year_data_map[year]['costOfRevenue'] += quarter.get('costOfRevenue', 0) or 0
                year_data_map[year]['grossProfit'] += quarter.get('grossProfit', 0) or 0
                year_data_map[year]['sellingGeneralAndAdministrative'] += quarter.get('sellingGeneralAndAdministrativeExpenses', 0) or 0
                year_data_map[year]['researchAndDevelopment'] += quarter.get('researchAndDevelopmentExpenses', 0) or 0
                year_data_map[year]['operatingExpenses'] += quarter.get('operatingExpenses', 0) or 0
                year_data_map[year]['operatingIncome'] += quarter.get('operatingIncome', 0) or 0
                year_data_map[year]['netIncome'] += quarter.get('netIncome', 0) or 0
                year_data_map[year]['eps'] += quarter.get('eps', 0) or 0
                year_data_map[year]['epsDiluted'] += quarter.get('epsDiluted', 0) or 0
        
        # Convert to FinancialDataResponse objects (only years with 4 complete quarters)
        for year in sorted(year_data_map.keys(), reverse=True):
            year_summary = year_data_map[year]
            
            # Only include years with 4 complete quarters
            if len(year_summary['quarters']) == 4:
                processed_year = FinancialDataResponse(
                    fiscalYear=str(year),
                    totalRevenue=int(year_summary['totalRevenue']),
                    costOfRevenue=int(year_summary['costOfRevenue']),
                    grossProfit=int(year_summary['grossProfit']),
                    sellingGeneralAndAdministrative=int(year_summary['sellingGeneralAndAdministrative']),
                    researchAndDevelopment=int(year_summary['researchAndDevelopment']),
                    operatingExpenses=int(year_summary['operatingExpenses']),
                    operatingIncome=int(year_summary['operatingIncome']),
                    netIncome=int(year_summary['netIncome']),
                    eps=round(year_summary['eps'], 2),
                    dilutedEps=round(year_summary['epsDiluted'], 2)
                )
                historical_data.append(processed_year)
            else:
                logger.warning(f"Skipping year {year} - only {len(year_summary['quarters'])} quarters available")
        
        # Generate analyst estimates for 2025-2027 using GAAP-adjusted hybrid approach
        # This matches the /projections endpoint behavior
        estimates_data = []
        
        try:
            # Get quarterly data and estimates from FMP
            quarterly_data = fmp_service.fetch_quarterly_income_statement(ticker)
            quarterly_estimates = fmp_service.fetch_quarterly_analyst_estimates(ticker)
            
            if quarterly_data and quarterly_estimates:
                from services.metrics_calculator import MetricsCalculator
                calculator = MetricsCalculator()
                
                # Get shares outstanding for EPS calculation
                stock_info = yfinance_service.fetch_stock_info(ticker)
                shares_outstanding = stock_info.get('shares_outstanding') if stock_info else None
                
                for year in [2025, 2026, 2027]:
                    try:
                        if year == current_year:  # Current year (2025)
                            # Use GAAP-adjusted hybrid approach (actual quarters + adjusted estimated quarters)
                            net_income = calculator._get_median_adjusted_hybrid_current_year_net_income(
                                quarterly_data, quarterly_estimates, year
                            )
                            revenue = calculator._get_hybrid_current_year_revenue(
                                quarterly_data, quarterly_estimates, year
                            )
                        else:  # Future years (2026, 2027)
                            # Use GAAP-adjusted estimates for all 4 quarters
                            net_income = calculator._get_median_adjusted_future_year_net_income(
                                quarterly_estimates, quarterly_data, quarterly_estimates, year
                            )
                            revenue = calculator._get_quarterly_estimates_revenue(
                                quarterly_estimates, year, 4
                            )
                        
                        # Calculate EPS and diluted EPS from net income
                        eps = None
                        diluted_eps = None
                        if net_income and shares_outstanding and shares_outstanding > 0:
                            eps = net_income / shares_outstanding
                            diluted_eps = eps * 0.99  # Assume 1% dilution
                        
                        estimate = AnalystEstimateResponse(
                            fiscalYear=str(year),
                            totalRevenue=int(revenue) if revenue else None,
                            netIncome=int(net_income) if net_income else None,
                            eps=round(eps, 2) if eps else None,
                            dilutedEps=round(diluted_eps, 2) if diluted_eps else None
                        )
                        estimates_data.append(estimate)
                        
                    except Exception as e:
                        logger.error(f"Error calculating GAAP-adjusted data for {ticker} {year}: {e}")
                        raise
            else:
                logger.error(f"Insufficient FMP data for {ticker}")
                raise HTTPException(
                    status_code=404,
                    detail=f"Insufficient data available for ticker {ticker}"
                )
                
        except Exception as e:
            logger.error(f"Error in GAAP-adjusted calculations for {ticker}: {e}")
            raise HTTPException(
                status_code=500,
                detail=f"Error calculating estimates: {str(e)}"
            )
        
        return ComprehensiveFinancialResponse(
            ticker=ticker.upper(),
            historical=historical_data,
            estimates=estimates_data
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Internal server error: {str(e)}"
        )


@app.get("/info")
def get_info(ticker: str = Query(..., description="Stock ticker symbol"), user: Dict = Depends(verify_token)):
    """
    Get basic stock information including price, market cap, and shares outstanding.
    
    Args:
        ticker: Stock ticker symbol (e.g., AAPL)
        
    Returns:
        JSON with ticker, price, market_cap, and shares_outstanding
    """
    try:
        yfinance_service = YFinanceService()
        
        # Get current price
        current_price = yfinance_service.get_current_price(ticker.upper())
        if current_price is None:
            raise HTTPException(
                status_code=404,
                detail=f"Unable to fetch price data for ticker {ticker}"
            )
        
        # Get market cap
        market_cap = yfinance_service.get_market_cap(ticker.upper())
        
        # Get shares outstanding
        shares_outstanding = yfinance_service.get_shares_outstanding(ticker.upper())
        
        return {
            "ticker": ticker.upper(),
            "price": current_price,
            "market_cap": int(market_cap) if market_cap else None,
            "shares_outstanding": int(shares_outstanding) if shares_outstanding else None
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": f"Internal server error: {str(e)}",
                "ticker": ticker.upper()
            }
        )


@app.get("/charts")
def get_chart_revenue(
    ticker: str = Query(..., description="Stock ticker symbol"),
    mode: str = Query("quarterly", description="Mode: 'quarterly' for quarterly data or 'ttm' for trailing twelve months"),
    user: Dict = Depends(verify_token)
):
    """
    Get quarterly revenue and EPS chart data for a ticker, including current price and market cap.
    Returns chart data with quarterly data plus current stock info.
    
    Args:
        ticker: Stock ticker symbol (e.g., AAPL)
        mode: Data mode - "quarterly" for quarterly data or "ttm" for trailing twelve months data
        
    Returns:
        Chart data with ticker, quarters, revenue, eps, price, and market_cap
    """
    try:
        chart_data = fetch_enhanced_chart_data(ticker.upper(), mode=mode)
        
        if chart_data is None:
            raise HTTPException(
                status_code=404,
                detail={
                    "error": f"Unable to fetch chart data for ticker {ticker}",
                    "ticker": ticker.upper()
                }
            )
        
        # Stock info removed - use /info endpoint instead
        
        # Return the chart data without redundant stock info
        return {
            'ticker': chart_data['ticker'],
            'quarters': chart_data['quarters'],
            'revenue': chart_data['revenue'],
            'eps': chart_data['eps'],
            'gross_margin': chart_data['gross_margin'],
            'net_margin': chart_data['net_margin'],
            'operating_income': chart_data['operating_income'],
            'operating_cash_flow': chart_data['operating_cash_flow'],
            'free_cash_flow': chart_data['free_cash_flow']
            # Stock info fields removed - use /info endpoint instead
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": f"Internal server error: {str(e)}",
                "ticker": ticker.upper()
            }
        )
